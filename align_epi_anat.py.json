{
    "command-line": "align_epi_anat.py [EPI] [ANAT] [EPI_BASE] [HELP] [ANAT2EPI] [EPI2ANAT] [DSET1] [DSET2] [DSET1TO2] [DSET2TO1] [SUFFIX] [CHILD_EPI] [SAVE_XXX] [CHILD_DSET2] [CHILD_ANAT] [CHILD_DSET1] [ADDEDGE] [BIG_MOVE] [GIANT_MOVE] [GINORMOUS_MOVE] [PARTIAL_COVERAGE] [PARTIAL_AXIAL] [PARTIAL_CORONAL] [PARTIAL_SAGITTAL] [KEEP_RM_FILES] [PREP_ONLY] [VERB] [ANAT_HAS_SKULL] [EPI_STRIP] [VOLREG_METHOD] [DSET1_STRIP] [DSET2_STRIP] [TLRC_APAR] [EX_MODE] [ALLINEATE_OPTS] [VOLREG] [TSHIFT] [TSHIFT_OPTS] [DEOBLIQUE] [MASTER_EPI] [MASTER_TLRC] [MASTER_ANAT] [MASTER_DSET1] [MASTER_DSET2] [CHECK_FLIP] [FLIP_GIANT] [SAVE_AL_IN] [SAVE_TSH] [SAVE_VR] [SAVE_SKULLSTRIP] [SAVE_REP] [SAVE_RESAMPLE] [SAVE_EPI_NS] [SAVE_ALL] [SAVE_ORIG_SKULLSTRIP] [SAVE_SCRIPT] [COST] [MULTI_COST] [CHECK_COST] [EDGE] [OUTPUT_DIR] [LIMITED_HELP] [OPTION_HELP] [VERSION] [VER] [ALIGN_CENTERS] [OVERWRITE] [RIGID_BODY] [PERC] [DSET2_BASE] [RESAMPLE] [PREP_OFF] [CMASS] [TLRC_EPAR] [AUTO_TLRC] [MASTER_ANAT_DXYZ] [MASTER_DSET1_DXYZ] [MASTER_EPI_DXYZ] [MASTER_DSET2_DXYZ] [MASTER_TLRC_DXYZ] [PRE_MATRIX] [POST_MATRIX] [SKULLSTRIP_OPTS] [FEATURE_SIZE] [RAT_ALIGN] [EDGE_ERODELEVEL] [POW_MASK] [BIN_MASK] [BOX_MASK] [MASK]",
    "description": "tool description",
    "inputs": [
        {
            "command-line-flag": "-epi",
            "description": "name of EPI dataset",
            "id": "EPI",
            "name": "EPI",
            "optional": true,
            "type": "String",
            "value-key": "[EPI]"
        },
        {
            "command-line-flag": "-anat",
            "description": "name of structural dataset",
            "id": "ANAT",
            "name": "ANAT",
            "optional": true,
            "type": "String",
            "value-key": "[ANAT]"
        },
        {
            "command-line-flag": "-epi_base",
            "description": "the epi base used in alignment (0/mean/median/max/subbrick#)  MAJOR OPTIONS:",
            "id": "EPI_BASE",
            "name": "EPI_BASE",
            "optional": true,
            "type": "String",
            "value-key": "[EPI_BASE]"
        },
        {
            "command-line-flag": "-help",
            "description": "this help message",
            "id": "HELP",
            "name": "HELP",
            "optional": true,
            "type": "String",
            "value-key": "[HELP]"
        },
        {
            "command-line-flag": "-anat2epi",
            "description": "align anatomical to EPI dataset (default)",
            "id": "ANAT2EPI",
            "name": "ANAT2EPI",
            "optional": true,
            "type": "String",
            "value-key": "[ANAT2EPI]"
        },
        {
            "command-line-flag": "-epi2anat",
            "description": "align EPI to anatomical dataset  The following options are equivalent to those epi/anat options above except it is assumed the datasets will have similar modalities if either dset1 or dset2 is specified, and the default cost function is changed to 'lpa' instead of 'lpc'. This should reduce confusion when aligning other types of datasets. Most other options that also have names with anat and epi have corresponding dset1 and dset2 options that are exactly equivalent.",
            "id": "EPI2ANAT",
            "name": "EPI2ANAT",
            "optional": true,
            "type": "String",
            "value-key": "[EPI2ANAT]"
        },
        {
            "command-line-flag": "-dset1",
            "description": "name of dataset1",
            "id": "DSET1",
            "name": "DSET1",
            "optional": true,
            "type": "String",
            "value-key": "[DSET1]"
        },
        {
            "command-line-flag": "-dset2",
            "description": "name of dataset2",
            "id": "DSET2",
            "name": "DSET2",
            "optional": true,
            "type": "String",
            "value-key": "[DSET2]"
        },
        {
            "command-line-flag": "-dset1to2",
            "description": "align dataset1 to dataset2",
            "id": "DSET1TO2",
            "name": "DSET1TO2",
            "optional": true,
            "type": "String",
            "value-key": "[DSET1TO2]"
        },
        {
            "command-line-flag": "-dset2to1",
            "description": "align dataset2 to dataset1",
            "id": "DSET2TO1",
            "name": "DSET2TO1",
            "optional": true,
            "type": "String",
            "value-key": "[DSET2TO1]"
        },
        {
            "command-line-flag": "-suffix",
            "description": "append suffix 'sss' to the original anat/epi dataset to use in the resulting dataset names (default is \"_al\")",
            "id": "SUFFIX",
            "name": "SUFFIX",
            "optional": true,
            "type": "String",
            "value-key": "[SUFFIX]"
        },
        {
            "command-line-flag": "-child_epi",
            "description": "-child_epi dset1 dset2 ... : specify other EPI datasets to align. Time series volume registration will be done to the same base as the main parent EPI dataset. Note if aligning anat to epi, you can still use the -save_vr option to save the volume registered (motion corrected) datasets. See the",
            "id": "CHILD_EPI",
            "name": "CHILD_EPI",
            "optional": true,
            "type": "String",
            "value-key": "[CHILD_EPI]"
        },
        {
            "command-line-flag": "-save_xxx",
            "description": "-save_xxx option section of this help for more information.",
            "id": "SAVE_XXX",
            "name": "SAVE_XXX",
            "optional": true,
            "type": "String",
            "value-key": "[SAVE_XXX]"
        },
        {
            "command-line-flag": "-child_dset2",
            "description": "-child_dset2  equivalent to child_epi above",
            "id": "CHILD_DSET2",
            "name": "CHILD_DSET2",
            "optional": true,
            "type": "String",
            "value-key": "[CHILD_DSET2]"
        },
        {
            "command-line-flag": "-child_anat",
            "description": "-child_anat dset1 dset2 ... : specify other anatomical datasets to align. The same transformation that is computed for the parent anatomical dataset is applied to each of the child datasets. This only makes sense for anat2epi transformations. Skullstripping is not done for the child anatomical dataset.",
            "id": "CHILD_ANAT",
            "name": "CHILD_ANAT",
            "optional": true,
            "type": "String",
            "value-key": "[CHILD_ANAT]"
        },
        {
            "command-line-flag": "-child_dset1",
            "description": "-child_dset1  equivalent to child_anat above",
            "id": "CHILD_DSET1",
            "name": "CHILD_DSET1",
            "optional": true,
            "type": "String",
            "value-key": "[CHILD_DSET1]"
        },
        {
            "command-line-flag": "-AddEdge",
            "description": "run @AddEdge script to create composite edge images of the base epi or anat dataset, the pre-aligned dataset and the aligned dataset. Datasets are placed in a separate directory named AddEdge. The @AddEdge can then be used without options to drive AFNI to show the epi and anat datasets with the edges enhanced. For the -anat2epi case (the default), the anat edges are shown in purple, and the epi edges are shown in cyan (light blue). For the -epi2anat case, the anat edges are shown in cyan, and the epi edges are purple. For both cases, overlapping edges are shown in dark purple.",
            "id": "ADDEDGE",
            "name": "ADDEDGE",
            "optional": true,
            "type": "String",
            "value-key": "[ADDEDGE]"
        },
        {
            "command-line-flag": "-big_move",
            "description": "indicates that large displacement is needed to align the two volumes. This option is off by default.",
            "id": "BIG_MOVE",
            "name": "BIG_MOVE",
            "optional": true,
            "type": "String",
            "value-key": "[BIG_MOVE]"
        },
        {
            "command-line-flag": "-giant_move",
            "description": "even larger movement required - uses cmass, two passes and very large angles and shifts. May miss finding the solution in the vastness of space, so use with caution",
            "id": "GIANT_MOVE",
            "name": "GIANT_MOVE",
            "optional": true,
            "type": "String",
            "value-key": "[GIANT_MOVE]"
        },
        {
            "command-line-flag": "-ginormous_move",
            "description": "adds align_centers to giant_move. Useful for very far apart datasets  Notes on the big_move and giant_move options: \"big_move\" allows for a two pass alignment in 3dAllineate. The two-pass method is less likely to find a false minimum cost for alignment because it does a number of coarse (blurred, rigid body) alignments first and then follows the best of these coarse alignments to the fine alignment stage. The big_move option should be a relatively safe option, but it adds processing time.  The giant_move option expands the search parameters in space from 6 degrees and 10 mm to 45 degrees and 45 mm and adds in a center of mass adjustment. The giant_move option will usually work well too, but it adds significant time to the processing and allows for the possibility of a very bad alignment.Another cost functional is available that has worked well with noisy data, \"lpc+ZZ\". For difficult data, consider that alternative.  If your data starts out fairly close (probably the typical case for EPI and anatomical data), you can use the -big_move with little problem. All these methods when used with the default lpc cost function require good contrast in the EPI image so that the CSF can be roughly identifiable.",
            "id": "GINORMOUS_MOVE",
            "name": "GINORMOUS_MOVE",
            "optional": true,
            "type": "String",
            "value-key": "[GINORMOUS_MOVE]"
        },
        {
            "command-line-flag": "-partial_coverage",
            "description": "indicates that the EPI dataset covers only a part of the brain. Alignment will try to guess which direction should not be shifted If EPI slices are known to be a specific orientation, use one of these other partial_xxxx options.",
            "id": "PARTIAL_COVERAGE",
            "name": "PARTIAL_COVERAGE",
            "optional": true,
            "type": "String",
            "value-key": "[PARTIAL_COVERAGE]"
        },
        {
            "command-line-flag": "-partial_axial",
            "description": "-partial_axial",
            "id": "PARTIAL_AXIAL",
            "name": "PARTIAL_AXIAL",
            "optional": true,
            "type": "String",
            "value-key": "[PARTIAL_AXIAL]"
        },
        {
            "command-line-flag": "-partial_coronal",
            "description": "-partial_coronal",
            "id": "PARTIAL_CORONAL",
            "name": "PARTIAL_CORONAL",
            "optional": true,
            "type": "String",
            "value-key": "[PARTIAL_CORONAL]"
        },
        {
            "command-line-flag": "-partial_sagittal",
            "description": "-partial_sagittal",
            "id": "PARTIAL_SAGITTAL",
            "name": "PARTIAL_SAGITTAL",
            "optional": true,
            "type": "String",
            "value-key": "[PARTIAL_SAGITTAL]"
        },
        {
            "command-line-flag": "-keep_rm_files",
            "description": "keep all temporary files (default is to remove them)",
            "id": "KEEP_RM_FILES",
            "name": "KEEP_RM_FILES",
            "optional": true,
            "type": "String",
            "value-key": "[KEEP_RM_FILES]"
        },
        {
            "command-line-flag": "-prep_only",
            "description": "do preprocessing steps only",
            "id": "PREP_ONLY",
            "name": "PREP_ONLY",
            "optional": true,
            "type": "String",
            "value-key": "[PREP_ONLY]"
        },
        {
            "command-line-flag": "-verb",
            "description": "provide verbose messages during processing (default is 0)",
            "id": "VERB",
            "name": "VERB",
            "optional": true,
            "type": "String",
            "value-key": "[VERB]"
        },
        {
            "command-line-flag": "-anat_has_skull",
            "description": "-anat_has_skull yes/no: Anat is assumed to have skull ([yes]/no)",
            "id": "ANAT_HAS_SKULL",
            "name": "ANAT_HAS_SKULL",
            "optional": true,
            "type": "String",
            "value-key": "[ANAT_HAS_SKULL]"
        },
        {
            "command-line-flag": "-epi_strip",
            "description": "method to mask brain in EPI data ([3dSkullStrip]/3dAutomask/None)",
            "id": "EPI_STRIP",
            "name": "EPI_STRIP",
            "optional": true,
            "type": "String",
            "value-key": "[EPI_STRIP]"
        },
        {
            "command-line-flag": "-volreg_method",
            "description": "method to do time series volume registration (motion correction) of EPI data ([3dvolreg],3dWarpDrive,3dAllineate). 3dvolreg is for 6 parameter (rigid-body) 3dWarpDrive is for 12 parameter (general affine) 3dAllineate - also 12 parameter with LPA cost function  Note if aligning anat to epi, the volume registered EPI dataset is **not** saved unless you use the -save_vr option. See the -save_xxx option section of this help for more information.",
            "id": "VOLREG_METHOD",
            "name": "VOLREG_METHOD",
            "optional": true,
            "type": "String",
            "value-key": "[VOLREG_METHOD]"
        },
        {
            "command-line-flag": "-dset1_strip",
            "description": "skull stripping method for dataset1",
            "id": "DSET1_STRIP",
            "name": "DSET1_STRIP",
            "optional": true,
            "type": "String",
            "value-key": "[DSET1_STRIP]"
        },
        {
            "command-line-flag": "-dset2_strip",
            "description": "skull stripping method for dataset2 (equivalent to epi_strip)  A template registered anatomical dataset such as a talairach-transformed dataset may be additionally specified so that output data are in template space. The advantage of specifying this transform here is that all transformations are applied simultaneously, thereby minimizing data interpolation.",
            "id": "DSET2_STRIP",
            "name": "DSET2_STRIP",
            "optional": true,
            "type": "String",
            "value-key": "[DSET2_STRIP]"
        },
        {
            "command-line-flag": "-tlrc_apar",
            "description": "-tlrc_apar ANAT+tlrc : structural dataset that has been aligned to a master template such as a tlrc dataset. If this option is supplied, then an epi+tlrc dataset will be created. The @auto_tlrc script may be used to create this \"talairach anatomical parent\". This option is only valid if aligning epi to anat.   Other options:",
            "id": "TLRC_APAR",
            "name": "TLRC_APAR",
            "optional": true,
            "type": "String",
            "value-key": "[TLRC_APAR]"
        },
        {
            "command-line-flag": "-ex_mode",
            "description": "execute mode (echo/dry_run/quiet/[script]). \"dry_run\" can be used to show the commands that would be executed without actually running them. \"echo\" shows the commands as they are executed. \"quiet\" doesn't display commands at all. \"script\" is like echo but doesn't show stdout, stderr header lines and \"cd\" lines. \"dry_run\" can be used to generate scripts which can be further customized beyond what may be available through the options of this program.",
            "id": "EX_MODE",
            "name": "EX_MODE",
            "optional": true,
            "type": "String",
            "value-key": "[EX_MODE]"
        },
        {
            "command-line-flag": "-Allineate_opts",
            "description": "-Allineate_opts '-ssss  -sss' : options to use with 3dAllineate. Default options are \"-weight_frac 1.0 -maxrot 6 -maxshf 10 -VERB -warp aff \"",
            "id": "ALLINEATE_OPTS",
            "name": "ALLINEATE_OPTS",
            "optional": true,
            "type": "String",
            "value-key": "[ALLINEATE_OPTS]"
        },
        {
            "command-line-flag": "-volreg",
            "description": "-volreg [on]/off : do volume registration on EPI dataset before alignment",
            "id": "VOLREG",
            "name": "VOLREG",
            "optional": true,
            "type": "String",
            "value-key": "[VOLREG]"
        },
        {
            "command-line-flag": "-tshift",
            "description": "-tshift [on]/off : do time shifting of EPI dataset before alignment",
            "id": "TSHIFT",
            "name": "TSHIFT",
            "optional": true,
            "type": "String",
            "value-key": "[TSHIFT]"
        },
        {
            "command-line-flag": "-tshift_opts",
            "description": "options to use with 3dTshift The script will determine if slice timing correction is necessary unless tshift is set to off.",
            "id": "TSHIFT_OPTS",
            "name": "TSHIFT_OPTS",
            "optional": true,
            "type": "String",
            "value-key": "[TSHIFT_OPTS]"
        },
        {
            "command-line-flag": "-deoblique",
            "description": "-deoblique [on]/off : deoblique datasets before alignment",
            "id": "DEOBLIQUE",
            "name": "DEOBLIQUE",
            "optional": true,
            "type": "String",
            "value-key": "[DEOBLIQUE]"
        },
        {
            "command-line-flag": "-master_epi",
            "description": "master grid resolution for aligned epi output",
            "id": "MASTER_EPI",
            "name": "MASTER_EPI",
            "optional": true,
            "type": "String",
            "value-key": "[MASTER_EPI]"
        },
        {
            "command-line-flag": "-master_tlrc",
            "description": "master grid resolution for epi+tlrc output",
            "id": "MASTER_TLRC",
            "name": "MASTER_TLRC",
            "optional": true,
            "type": "String",
            "value-key": "[MASTER_TLRC]"
        },
        {
            "command-line-flag": "-master_anat",
            "description": "master grid resolution for aligned anatomical data output",
            "id": "MASTER_ANAT",
            "name": "MASTER_ANAT",
            "optional": true,
            "type": "String",
            "value-key": "[MASTER_ANAT]"
        },
        {
            "command-line-flag": "-master_dset1",
            "description": "equivalent to master_anat above",
            "id": "MASTER_DSET1",
            "name": "MASTER_DSET1",
            "optional": true,
            "type": "String",
            "value-key": "[MASTER_DSET1]"
        },
        {
            "command-line-flag": "-master_dset2",
            "description": "equivalent to master_epi above (SOURCE/BASE/MIN_DXYZ/dsetname/n.nn) Each of the 'master' options can be set to SOURCE,BASE, a specific master dataset, MIN_DXYZ or a specified cubic voxel size in mm.  MIN_DXYZ uses the smallest voxel dimension as the basis for cubic output voxel resolution within the bounding box of the BASE dataset.  SOURCE and BASE are used as in 3dAllineate help.  The default value for master_epi and master_anat is SOURCE, that is the output resolution and coordinates should be the same as the input. This is appropriate for small movements.  For cases where either dataset is oblique (and larger rotations can occur), the default becomes MIN_DXYZ.  The default value for master_tlrc is MIN_DXYZ.  \"-master_dset1\" and \"-master_dset2\" may be used as equivalent expressions for anat and epi output resolutions, respectively.",
            "id": "MASTER_DSET2",
            "name": "MASTER_DSET2",
            "optional": true,
            "type": "String",
            "value-key": "[MASTER_DSET2]"
        },
        {
            "command-line-flag": "-check_flip",
            "description": "check if data may have been left/right flipped by aligning original and flipped versions and then comparing costs between the two. This option produces the L/R flipped and aligned anat/dset1 dataset. A warning is printed if the flipped data has a lower cost function value than the original dataset when both are aligned to the epi/dset2 dataset.  This issue of left-right confusion can be caused by problems with DICOM files or pipelines that include Analyze format datasets. In these cases, the orientation information is lost, and left-right may be reversed. Other directions can also be confused, but A-P and I-S are usually obvious. Note this problem has appeared on several major publicly available databases. Even if other software packages may proceed without errors despite inconsistent, wrong or even missing coordinate and orientation information, this problem can be easily identified with this option.  This option does not identify which of the two datasets need to be flipped. It only determines there is likely to be a problem with one or the other of the two input datasets. Importantly, we recommend properly visualizing the datasets in the afni GUI. Look for asymmetries in the two aligned anat/dset1 datasets, and see how they align with the epi/dset2 dataset. To better determine the left and right of each dataset, we recommend relying on tags like vitamin E or looking for surgical markers.",
            "id": "CHECK_FLIP",
            "name": "CHECK_FLIP",
            "optional": true,
            "type": "String",
            "value-key": "[CHECK_FLIP]"
        },
        {
            "command-line-flag": "-flip_giant",
            "description": "apply giant_move options to flipped dataset alignment even if not using that option for original dataset alignment",
            "id": "FLIP_GIANT",
            "name": "FLIP_GIANT",
            "optional": true,
            "type": "String",
            "value-key": "[FLIP_GIANT]"
        },
        {
            "command-line-flag": "-save_Al_in",
            "description": "save 3dAllineate input files",
            "id": "SAVE_AL_IN",
            "name": "SAVE_AL_IN",
            "optional": true,
            "type": "String",
            "value-key": "[SAVE_AL_IN]"
        },
        {
            "command-line-flag": "-save_tsh",
            "description": "save tshifted epi",
            "id": "SAVE_TSH",
            "name": "SAVE_TSH",
            "optional": true,
            "type": "String",
            "value-key": "[SAVE_TSH]"
        },
        {
            "command-line-flag": "-save_vr",
            "description": "save volume registered epi",
            "id": "SAVE_VR",
            "name": "SAVE_VR",
            "optional": true,
            "type": "String",
            "value-key": "[SAVE_VR]"
        },
        {
            "command-line-flag": "-save_skullstrip",
            "description": "save skull-stripped (not aligned)",
            "id": "SAVE_SKULLSTRIP",
            "name": "SAVE_SKULLSTRIP",
            "optional": true,
            "type": "String",
            "value-key": "[SAVE_SKULLSTRIP]"
        },
        {
            "command-line-flag": "-save_rep",
            "description": "save representative tstat epi",
            "id": "SAVE_REP",
            "name": "SAVE_REP",
            "optional": true,
            "type": "String",
            "value-key": "[SAVE_REP]"
        },
        {
            "command-line-flag": "-save_resample",
            "description": "save resampled epi",
            "id": "SAVE_RESAMPLE",
            "name": "SAVE_RESAMPLE",
            "optional": true,
            "type": "String",
            "value-key": "[SAVE_RESAMPLE]"
        },
        {
            "command-line-flag": "-save_epi_ns",
            "description": "save skull-stripped epi",
            "id": "SAVE_EPI_NS",
            "name": "SAVE_EPI_NS",
            "optional": true,
            "type": "String",
            "value-key": "[SAVE_EPI_NS]"
        },
        {
            "command-line-flag": "-save_all",
            "description": "save all the above datasets  Not included with -save_all (since parameters are required):",
            "id": "SAVE_ALL",
            "name": "SAVE_ALL",
            "optional": true,
            "type": "String",
            "value-key": "[SAVE_ALL]"
        },
        {
            "command-line-flag": "-save_orig_skullstrip",
            "description": "save original skull-stripped dset",
            "id": "SAVE_ORIG_SKULLSTRIP",
            "name": "SAVE_ORIG_SKULLSTRIP",
            "optional": true,
            "type": "String",
            "value-key": "[SAVE_ORIG_SKULLSTRIP]"
        },
        {
            "command-line-flag": "-save_script",
            "description": "save shell command script to given file  Alternative cost functions and methods: The default method used in this script is the LPC (Localized Pearson Correlation) function. The 'lpc' cost function is computed by the 3dAllineate program. Other cost functionals are available and are described briefly in the help for 3dAllineate. This script allows the user to choose any cost function available in that program with",
            "id": "SAVE_SCRIPT",
            "name": "SAVE_SCRIPT",
            "optional": true,
            "type": "String",
            "value-key": "[SAVE_SCRIPT]"
        },
        {
            "command-line-flag": "-cost",
            "description": "-cost xxx  Some cost functionals have proven to be useful for some situations. Briefly, when aligning similar datasets (anat to anat), the 'lpa' method usually provides good alignment. Instead of using a negative correlation, as the 'lpc' method does, the 'lpa' cost functional uses the absolute value of the local correlation, so both positive and negative correlations drive the alignment. Occasionally the simplest least squares cost functional will be useful (implemented with -ls).  If either of the input datasets has very little structural detail (less than typical EPI), the mutual information methods provide a rough alignment that gives alignment of mostly the contour of the datasets. These are implemented with '-cost nmi' or '-cost mi'.  The lpa cost function looks for both high positive and negative local Pearson correlation (LPA is an acronym in our program for the absolute value of the local Pearson correlation). The LPC method looks for negative correlation, essentially matching the dark CSF in T1 images with the bright CSF in EPI images. The more negative the correlation the more likely the CSF will overlay each other and carry the rest of the volume along with it.",
            "id": "COST",
            "name": "COST",
            "optional": true,
            "type": "String",
            "value-key": "[COST]"
        },
        {
            "command-line-flag": "-multi_cost",
            "description": "-multi_cost cf1 cf2 ... Besides cost from specified cost function or default cost function, also compute alignment using other cost functionals. For example, using \"-cost lpa -multi_cost ls nmi\" will compute an alignment for the lpa, ls and nmi cost functionals. See 3dAllineate's HELP for a full list of available cost functionals. Use the AFNI GUI to view differences among cost functionals.",
            "id": "MULTI_COST",
            "name": "MULTI_COST",
            "optional": true,
            "type": "String",
            "value-key": "[MULTI_COST]"
        },
        {
            "command-line-flag": "-check_cost",
            "description": "-check_cost cf1 cf2 ... Verify alignment against another cost functional. If there is a large difference, a warning is printed. This does not mean the alignment is bad, only that it is different.",
            "id": "CHECK_COST",
            "name": "CHECK_COST",
            "optional": true,
            "type": "String",
            "value-key": "[CHECK_COST]"
        },
        {
            "command-line-flag": "-edge",
            "description": "use edge method  The Edge method Finally, the \"edge\" method is a new method that is implemented not as a cost functional but as a different algorithm altogether. Based on our visualization methods for verifying alignment (as we do in AddEdge), it uses a local approach like the LPA/C cost functionals, but it is independent of the cost function.  This method has turned out to be useful in a variety of circumstances. It has proven useful for data that changes dramatically over time like manganese-enhanced MRI (MEMRI) and for some data that has other large non-uniformities issues helping to compensate for those large contrasts.  The edge method prepares the image to be a local spatial variance version of the original image. First both input datasets are automasked with the outer voxel layers removed. The spatial variance is computed over that mask. The optimal alignment is computed between the edge images. Strictly speaking, the datasets are not \"edges\" but a kind of normalized 2D gradient. The original datasets are then aligned using the transformation computed by the edge image alignment. Internally within the script, the gradient function is accomplished by the 3dLocalstat program using its cvar option for coefficient of variation. The coefficient of variation is computed as the standard deviation within the local neighborhood divided by the mean. The local spatial variance ends up being similar to locally normalized images of edges within the image.  The \"-edge\" option is relatively insensitive to most of the cost functions in 3dAllineate, so \"lpa\", \"mi\", \"nmi\" and even \"ls\" will usually work well. The default is to use the lpa cost functional together with the edge method.  The edge image is different in a couple ways from the LPA/C correlation. First it is a different function, essentially only a standard deviation over a neighborhood, and then normalized by the absolute value of the mean - effectively a spatial variance (or square root of the variance). The second difference is that while the LPA/C cost functions also operates on local neighborhoods, those neighborhoods are 3-dimensional and set by a neighborhood size set in mm. The shape of the neighborhoods are dodecahedrons (12-side figures) that cover the volume. The edge method instead computes the neighborhoods at each voxel, and the neighborhoods are only two-dimensional - just the voxel and its 8 neighbors in x and y, presumed to be in the same slice rather than across slices. That's for both speed in computation and to remove effects of interpolation or false edges across the relatively distant slices.  Although not as rigorously tested as the LPC method, this edge method seems to give similar results most of the time. The method does have a few disadvantages compared to the LPC/LPA methods. First, the AddEdge visualization in this script does not support this well (effectively, showing edges of edges). Second, the edge method does not provide three-dimensional edge detection directly. Many times this is an advantage, but if the data has particularly fine slicing in the z-direction, or the data has been resampled, this method may not work as well. Also the method uses an automask to reduce the data so that outside edges do not drive the alignment. The five voxel layer was only empirically found to be useful for this, but may, in fact, be problematic for small partial volumes or for surface coil data where much of the data may be in the area that is masked away.  The edge method makes no assumption about contrasts between images. Only that edges of features will overlap - the same feature we use visually to verify alignment. This makes it appropriate for both similar and differing modality datasets.  Both the LPA/LPC and the edge methods require internal features to be present and mostly corresponding in both input datasets. In some cases, this correspondence is not available for aligning some kinds of data with an anatomical references - low-contrast EPI data, radiopharmaceutical PET data targeting specific function, derived parameters from modeling. In these cases, fine alignment is not possible, but alternative cost functions like mutual information or least squares can provide a rough alignment of the contours.",
            "id": "EDGE",
            "name": "EDGE",
            "optional": true,
            "type": "String",
            "value-key": "[EDGE]"
        },
        {
            "command-line-flag": "-output_dir",
            "description": "the default output will put the result in the current directory even if the anat and epi datasets are in other directories. If a directory is specified here, output data including temporary output data will be placed in that directory. If a new directory is specified, that directory will be created first.  Other obscure and experimental options that should only be handled with care, lest they get out, are visible with -option_help.  Examples: # align anat to sub-brick 5 of epi+orig. In addition, do slice timing # correction on epi+orig and register all sub-bricks to sub-brick 5 # (Sample data files are in AFNI_data4/sb23 in sample class data) # Note the intermediate file, the volume registered EPI dataset, # is **not** saved unless the -save_vr option is also used. # See the -save_xxx option section of this help for more information.  align_epi_anat.py -anat sb23_mpra+orig -epi epi_r03+orig     \\ -epi_base 5  # Instead of aligning the anatomy to an epi, transform the epi # to match the anatomy. Transform other epi run datasets to be # in alignment with the first epi datasets and with the anatomical # reference dataset. Note that all epi sub-bricks from all runs # are transformed only once in the process, combining volume # registration and alignment to the anatomical dataset in a single # transformation matrix  align_epi_anat.py -anat sb23_mpra+orig -epi epi_r03+orig      \\ -epi_base 5 -child_epi epi_r??+orig.HEAD    \\ -epi2anat -suffix al2anat  # Bells and whistles: # - create Talairach transformed epi datasets (still one transform) # - do not execute, just show the commands that would be executed. #   These commands can be saved in a script or modified. # The Talairach transformation requires auto-Talairaching # the anatomical dataset first (cf. @auto_tlrc script)  @auto_tlrc -base ~/abin/TT_N27+tlrc -input sb23_mpra+orig align_epi_anat.py -anat sb23_mpra+orig -epi epi_r03+orig      \\ -epi_base 6 -child_epi epi_r??+orig.HEAD    \\ -ex_mode dry_run -epi2anat -suffix _altest  \\",
            "id": "OUTPUT_DIR",
            "name": "OUTPUT_DIR",
            "optional": true,
            "type": "String",
            "value-key": "[OUTPUT_DIR]"
        },
        {
            "command-line-flag": "-limited_help",
            "description": "-limited_help use:                The main help without all available options",
            "id": "LIMITED_HELP",
            "name": "LIMITED_HELP",
            "optional": true,
            "type": "String",
            "value-key": "[LIMITED_HELP]"
        },
        {
            "command-line-flag": "-option_help",
            "description": "-option_help use:                Help for all available options",
            "id": "OPTION_HELP",
            "name": "OPTION_HELP",
            "optional": true,
            "type": "String",
            "value-key": "[OPTION_HELP]"
        },
        {
            "command-line-flag": "-version",
            "description": "-version use:                Show version number and exit",
            "id": "VERSION",
            "name": "VERSION",
            "optional": true,
            "type": "String",
            "value-key": "[VERSION]"
        },
        {
            "command-line-flag": "-ver",
            "description": "-ver use:                Show version number and exit",
            "id": "VER",
            "name": "VER",
            "optional": true,
            "type": "String",
            "value-key": "[VER]"
        },
        {
            "command-line-flag": "-align_centers",
            "description": "-align_centers use:                align centers of datasets based on spatial extents of the original volume allowed:            yes, no, on, off default:            no",
            "id": "ALIGN_CENTERS",
            "name": "ALIGN_CENTERS",
            "optional": true,
            "type": "String",
            "value-key": "[ALIGN_CENTERS]"
        },
        {
            "command-line-flag": "-overwrite",
            "description": "-overwrite use:                Overwrite existing files -big_move use:                Large movement between epi and anat. Uses twopass option for 3dAllineate. Consider cmass options, giant_move, ginormous_move or -align_centers -giant_move use:                Even larger movement between epi and anat. Uses twopass option for 3dAllineate. cmass options and wide angles and shifts -ginormous_move use:                Adds align_centers to giant_move",
            "id": "OVERWRITE",
            "name": "OVERWRITE",
            "optional": true,
            "type": "String",
            "value-key": "[OVERWRITE]"
        },
        {
            "command-line-flag": "-rigid_body",
            "description": "-rigid_body use:                Do only rigid body alignment - shifts and rotates -partial_coverage use:                partial_xxxx options control center of mass adjustment",
            "id": "RIGID_BODY",
            "name": "RIGID_BODY",
            "optional": true,
            "type": "String",
            "value-key": "[RIGID_BODY]"
        },
        {
            "command-line-flag": "-perc",
            "description": "-perc default:            90 -suffix default:            _al",
            "id": "PERC",
            "name": "PERC",
            "optional": true,
            "type": "String",
            "value-key": "[PERC]"
        },
        {
            "command-line-flag": "-dset2_base",
            "description": "-dset2_base use:                Base sub-brick to use for alignment Choose sub-brick number or statistic type Valid choices can be, for example, 0,5,mean",
            "id": "DSET2_BASE",
            "name": "DSET2_BASE",
            "optional": true,
            "type": "String",
            "value-key": "[DSET2_BASE]"
        },
        {
            "command-line-flag": "-resample",
            "description": "-resample allowed:            on, off",
            "id": "RESAMPLE",
            "name": "RESAMPLE",
            "optional": true,
            "type": "String",
            "value-key": "[RESAMPLE]"
        },
        {
            "command-line-flag": "-prep_off",
            "description": "-prep_off use:                turn off all pre-processing steps including deoblique, tshift, volreg and resample",
            "id": "PREP_OFF",
            "name": "PREP_OFF",
            "optional": true,
            "type": "String",
            "value-key": "[PREP_OFF]"
        },
        {
            "command-line-flag": "-cmass",
            "description": "-cmass use:                center of mass options for 3dAllineate Valid options include cmass+a, cmass+xy, nocmass",
            "id": "CMASS",
            "name": "CMASS",
            "optional": true,
            "type": "String",
            "value-key": "[CMASS]"
        },
        {
            "command-line-flag": "-tlrc_epar",
            "description": "-tlrc_epar use:                Not available yet. If this is set, the results will include +tlrc template transformed datasets for the anatomical aligned to the epi combined with this additional transformation to template of this parent dataset The result will be ANAT_al+tlrc.HEAD",
            "id": "TLRC_EPAR",
            "name": "TLRC_EPAR",
            "optional": true,
            "type": "String",
            "value-key": "[TLRC_EPAR]"
        },
        {
            "command-line-flag": "-auto_tlrc",
            "description": "-auto_tlrc use:                Not available yet. If this is set, the results will also be aligned to a template using the @auto_tlrc script. Transformations computed from that will be combined with the anat to epi transformations and epi to anat (and volreg) transformations 0nly one of the -tlrc_apar, -tlrc_epar or the",
            "id": "AUTO_TLRC",
            "name": "AUTO_TLRC",
            "optional": true,
            "type": "String",
            "value-key": "[AUTO_TLRC]"
        },
        {
            "command-line-flag": "-master_anat_dxyz",
            "description": "-master_anat_dxyz use:                -master grid resolution size (cubic only)",
            "id": "MASTER_ANAT_DXYZ",
            "name": "MASTER_ANAT_DXYZ",
            "optional": true,
            "type": "String",
            "value-key": "[MASTER_ANAT_DXYZ]"
        },
        {
            "command-line-flag": "-master_dset1_dxyz",
            "description": "-master_dset1_dxyz use:                -master grid resolution size (cubic only)",
            "id": "MASTER_DSET1_DXYZ",
            "name": "MASTER_DSET1_DXYZ",
            "optional": true,
            "type": "String",
            "value-key": "[MASTER_DSET1_DXYZ]"
        },
        {
            "command-line-flag": "-master_epi_dxyz",
            "description": "-master_epi_dxyz use:                -master grid resolution (cubic only)",
            "id": "MASTER_EPI_DXYZ",
            "name": "MASTER_EPI_DXYZ",
            "optional": true,
            "type": "String",
            "value-key": "[MASTER_EPI_DXYZ]"
        },
        {
            "command-line-flag": "-master_dset2_dxyz",
            "description": "-master_dset2_dxyz use:                -master grid resolution (cubic only)",
            "id": "MASTER_DSET2_DXYZ",
            "name": "MASTER_DSET2_DXYZ",
            "optional": true,
            "type": "String",
            "value-key": "[MASTER_DSET2_DXYZ]"
        },
        {
            "command-line-flag": "-master_tlrc_dxyz",
            "description": "-master_tlrc_dxyz use:                -master grid resolution (cubic only)",
            "id": "MASTER_TLRC_DXYZ",
            "name": "MASTER_TLRC_DXYZ",
            "optional": true,
            "type": "String",
            "value-key": "[MASTER_TLRC_DXYZ]"
        },
        {
            "command-line-flag": "-pre_matrix",
            "description": "-pre_matrix use:                Apply an initial transformation from a 1D file. For example, this file may be one generated by @Align_Centers. The transformation will be applied to the anatomical data before aligning to the EPI instead of using the built-in obliquity matrices, if any",
            "id": "PRE_MATRIX",
            "name": "PRE_MATRIX",
            "optional": true,
            "type": "String",
            "value-key": "[PRE_MATRIX]"
        },
        {
            "command-line-flag": "-post_matrix",
            "description": "-post_matrix use:                Apply an additional transformation from a 1D file. This transformation will be applied to the anatomical data after alignment with the EPI. This will be applied similarly to the tlrc transformation and in place of it. Output datasets are kept in the 'orig' view",
            "id": "POST_MATRIX",
            "name": "POST_MATRIX",
            "optional": true,
            "type": "String",
            "value-key": "[POST_MATRIX]"
        },
        {
            "command-line-flag": "-skullstrip_opts",
            "description": "-skullstrip_opts use:                Alternate options for 3dSkullstrip. like -rat or -blur_fwhm 2",
            "id": "SKULLSTRIP_OPTS",
            "name": "SKULLSTRIP_OPTS",
            "optional": true,
            "type": "String",
            "value-key": "[SKULLSTRIP_OPTS]"
        },
        {
            "command-line-flag": "-feature_size",
            "description": "-feature_size use:                Minimal size in mm of structures in images to match. Changes options for 3dAllineate for the coarse blurring and lpc/lpa neighborhood sizes.May be useful for rat brains, anat to anat and other 'non-standard' alignment",
            "id": "FEATURE_SIZE",
            "name": "FEATURE_SIZE",
            "optional": true,
            "type": "String",
            "value-key": "[FEATURE_SIZE]"
        },
        {
            "command-line-flag": "-rat_align",
            "description": "-rat_align use:                Set options appropriate for rat data - namely skullstrip and feature size options above.  -output_dir use:                Set directory for output datasets  -edge use:                Use internal edges to do alignment",
            "id": "RAT_ALIGN",
            "name": "RAT_ALIGN",
            "optional": true,
            "type": "String",
            "value-key": "[RAT_ALIGN]"
        },
        {
            "command-line-flag": "-edge_erodelevel",
            "description": "-edge_erodelevel use:                Number of layers to remove for edge method -check_flip use:                Check if L/R flipping gives better results -flip_giant use:                use giant_move on flipped data even if not used on original data -save_Al_in use:                Save datasets used as input to 3dAllineate -save_vr use:                Save motion-corrected epi dataset -save_tsh use:                Save time-series corrected dataset -save_skullstrip use:                Save unaligned, skullstripped dataset -save_orig_skullstrip use:                Save simply skullstripped dataset -save_epi_ns use:                Save unaligned, skullstripped EPI dataset -save_rep use:                Save unaligned representative tstat EPI dataset -save_resample use:                Save unaligned EPI dataset resampled to anat grid -save_all use:                Save all optional datasets",
            "id": "EDGE_ERODELEVEL",
            "name": "EDGE_ERODELEVEL",
            "optional": true,
            "type": "String",
            "value-key": "[EDGE_ERODELEVEL]"
        },
        {
            "command-line-flag": "-pow_mask",
            "description": "-pow_mask use:                power for weighting 1 or 2 default:            1.0",
            "id": "POW_MASK",
            "name": "POW_MASK",
            "optional": true,
            "type": "String",
            "value-key": "[POW_MASK]"
        },
        {
            "command-line-flag": "-bin_mask",
            "description": "-bin_mask use:                convert weighting mask to 0 or 1 - Unused allowed:            yes, no default:            no",
            "id": "BIN_MASK",
            "name": "BIN_MASK",
            "optional": true,
            "type": "String",
            "value-key": "[BIN_MASK]"
        },
        {
            "command-line-flag": "-box_mask",
            "description": "-box_mask use:                Unused allowed:            yes, no default:            no",
            "id": "BOX_MASK",
            "name": "BOX_MASK",
            "optional": true,
            "type": "String",
            "value-key": "[BOX_MASK]"
        },
        {
            "command-line-flag": "-mask",
            "description": "-mask use:                Not available yet. Mask to apply to data. default:            vent",
            "id": "MASK",
            "name": "MASK",
            "optional": true,
            "type": "String",
            "value-key": "[MASK]"
        }
    ],
    "name": "tool name",
    "schema-version": "0.5",
    "suggested-resources": {
        "cpu-cores": 1,
        "ram": 1,
        "walltime-estimate": 60
    },
    "tags": {},
    "tool-version": "v0.1.0"
}
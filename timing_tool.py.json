{
    "command-line": "timing_tool.py [RUN_LEN] [MULTI_STIM_DUR] [STIM_TIMES] [MULTI_TIMING] [GLOBAL_TO_LOCAL] [LOCAL_TO_GLOBAL] [MULTI_TIMING_TO_EVENT_LIST] [SELECT_RUNS] [HELP] [HELP_BASIS] [HIST] [SHOW_VALID_OPTS] [VER] [TIMING] [SHOW_ISI_STATS] [SHOW_TIMING_ELE] [STIM_DUR] [FSL_TIMING_FILES] [MULTI_SHOW_DURATION_STATS] [MULTI_SHOW_ISI_STATS] [MULTI_SHOW_TIMING_ELE] [WRITE_MULTI_TIMING] [ADD_OFFSET] [APPLY_END_TIMES_AS_DURATIONS] [ADD_ROWS] [EXTEND] [MARRY_AM] [PARTITION] [ROUND_TIMES] [SCALE_DATA] [SHOW_DURATION_STATS] [SHOW_TIMING] [SHOW_TR_STATS] [WARN_TR_STATS] [SORT] [TEST_LOCAL_TIMING] [TIMING_TO_1D] [TRANSPOSE] [TRUNCATE_TIMES] [WRITE_AS_MARRIED] [WRITE_TIMING] [MULTI_TIMING_TO_EVENTS] [MULTI_TIMING_TO_EVENT_PAIR] [CHRONO] [MIN_FRAC] [PART_INIT] [NPLACES] [MPLACES] [PER_RUN] [PER_RUN_FILE] [TR] [VERB] [WRITE_ALL_REST_TIMES]",
    "description": "tool description",
    "inputs": [
        {
            "command-line-flag": "-run_len",
            "description": "-run_len 200 -multi_stim_dur 3.5     \\ -multi_show_isi_stats  Example 4. Show timing statistics for the timing files generated by example 6 from \"make_random_timing -help\".  Since both the run and stimulus durations vary, 4 run lengths and 3 stimulus durations are given.  timing_tool.py -multi_timing stimesF_*.1D           \\",
            "id": "RUN_LEN",
            "name": "RUN_LEN",
            "optional": true,
            "type": "String",
            "value-key": "[RUN_LEN]"
        },
        {
            "command-line-flag": "-multi_stim_dur",
            "description": "-multi_stim_dur 3.5 4.5 3            \\ -multi_show_isi_stats  Example 5. Partition the stimulus timing file 'response_times.1D' into multiple timing files based on the labels in a partition file, partitions.1D.  If partitions.txt contains (0, correct, incorrect), there will be 2 output timing files, new_times_correct.1D and new_times_incorrect.1D. Times where the partition label is '0' will be skipped.  timing_tool.py -timing response_times.1D       \\ -partition partitions.txt new_times  Example 6a. Convert a stim_times timing file to 0/1 stim_file format. Suppose the timing is random where each event lasts 2.5 seconds and runs are of lengths 360, 360 and 400 seconds.  Convert timing.txt to sfile.1D on a TR grid of 0.5 seconds (oversampling), where a TR gets an event if at least 30% of the TR is is occupied by stimulus.  timing_tool.py -timing timing.txt -timing_to_1D sfile.1D      \\ -tr 0.5 -stim_dur 2.5 -min_frac 0.3            \\",
            "id": "MULTI_STIM_DUR",
            "name": "MULTI_STIM_DUR",
            "optional": true,
            "type": "String",
            "value-key": "[MULTI_STIM_DUR]"
        },
        {
            "command-line-flag": "-stim_times",
            "description": "-stim_times 1 timing.txt 'BLOCK(2.5)'            \\ -x1D X.xmat.1D -x1D_stop  1dplot -sepscl sfile.1D waver.1D X.xmat.1D  Example 6c. Do this per run, but leave each run in a separate file.  timing_tool.py -timing timing.txt -timing_to_1D sfile.1D      \\ -tr 0.5 -stim_dur 2.5 -min_frac 0.3            \\",
            "id": "STIM_TIMES",
            "name": "STIM_TIMES",
            "optional": true,
            "type": "String",
            "value-key": "[STIM_TIMES]"
        },
        {
            "command-line-flag": "-multi_timing",
            "description": "-multi_timing_to_events all.events.txt      \\ -tr 1.25 -multi_stim_dur 1 -min_frac 0.5    \\ -per_run -run_len 370  Example 8b. Break the event list into 2, one for a sequence of changing event types, one for a sequence of ISIs (TRs from one event to the next, including the TR of the event).  So if the event file from #8 shows: 0 0 3 0 0 0 0 1 0 2 2 0 0 0 ... The resulting event/ISI files would read: event: 0 3 1 2 2 ... ISI:   2 5 2 1 4 ...  timing_tool.py -multi_timing stimes.*.txt            \\",
            "id": "MULTI_TIMING",
            "name": "MULTI_TIMING",
            "optional": true,
            "type": "String",
            "value-key": "[MULTI_TIMING]"
        },
        {
            "command-line-flag": "-global_to_local",
            "description": "-global_to_local local.1D                      \\",
            "id": "GLOBAL_TO_LOCAL",
            "name": "GLOBAL_TO_LOCAL",
            "optional": true,
            "type": "String",
            "value-key": "[GLOBAL_TO_LOCAL]"
        },
        {
            "command-line-flag": "-local_to_global",
            "description": "-local_to_global global.1D                      \\",
            "id": "LOCAL_TO_GLOBAL",
            "name": "LOCAL_TO_GLOBAL",
            "optional": true,
            "type": "String",
            "value-key": "[LOCAL_TO_GLOBAL]"
        },
        {
            "command-line-flag": "-multi_timing_to_event_list",
            "description": "dotf elist13b.txt  Example 14. Partition one stimulus class based on others.  Class '1' (from the first input) is partitioned based on the class that precedes it.  If none precede an early class 1 event, event INIT is used as the default (else consider '-part_init 2', for example).  timing_tool.py -multi_timing stimes.*.txt            \\",
            "id": "MULTI_TIMING_TO_EVENT_LIST",
            "name": "MULTI_TIMING_TO_EVENT_LIST",
            "optional": true,
            "type": "String",
            "value-key": "[MULTI_TIMING_TO_EVENT_LIST]"
        },
        {
            "command-line-flag": "-select_runs",
            "description": "-select_runs 0 0 1 0 -write_timing NEW.txt  Example 18d. Apply two FSL runs as run 3 and 4 of a 5-run timing file.  The original runs can be duplicated, put into a new order or omitted. Also, truncate the event times to 1 place after the decimal (-nplaces), and similarly truncate the married terms (durations and/or amplitudes) to 1 place after the decimal (-mplaces).  timing_tool.py -fsl_timing_files fsl_r1.txt fsl_r2.txt \\ -nplaces 1 -mplaces 1 -write_as_married \\",
            "id": "SELECT_RUNS",
            "name": "SELECT_RUNS",
            "optional": true,
            "type": "String",
            "value-key": "[SELECT_RUNS]"
        },
        {
            "command-line-flag": "-help",
            "description": "show this help",
            "id": "HELP",
            "name": "HELP",
            "optional": true,
            "type": "String",
            "value-key": "[HELP]"
        },
        {
            "command-line-flag": "-help_basis",
            "description": "describe various basis functions",
            "id": "HELP_BASIS",
            "name": "HELP_BASIS",
            "optional": true,
            "type": "String",
            "value-key": "[HELP_BASIS]"
        },
        {
            "command-line-flag": "-hist",
            "description": "show the module history",
            "id": "HIST",
            "name": "HIST",
            "optional": true,
            "type": "String",
            "value-key": "[HIST]"
        },
        {
            "command-line-flag": "-show_valid_opts",
            "description": "show all valid options",
            "id": "SHOW_VALID_OPTS",
            "name": "SHOW_VALID_OPTS",
            "optional": true,
            "type": "String",
            "value-key": "[SHOW_VALID_OPTS]"
        },
        {
            "command-line-flag": "-ver",
            "description": "show the version number  ------------------------------------------ options with both single and multi versions (all single first):",
            "id": "VER",
            "name": "VER",
            "optional": true,
            "type": "String",
            "value-key": "[VER]"
        },
        {
            "command-line-flag": "-timing",
            "description": "specify a stimulus timing file to load  e.g. -timing stimesB_01_houses.1D  Use this option to specify a single stimulus timing file.  The user can modify this timing via some of the action options listed below.",
            "id": "TIMING",
            "name": "TIMING",
            "optional": true,
            "type": "String",
            "value-key": "[TIMING]"
        },
        {
            "command-line-flag": "-show_isi_stats",
            "description": "display timing and ISI statistics  With this option, the program will display timing statistics for the single (possibly modified) timing element.  If -tr is included, TR offset statistics are also shown.",
            "id": "SHOW_ISI_STATS",
            "name": "SHOW_ISI_STATS",
            "optional": true,
            "type": "String",
            "value-key": "[SHOW_ISI_STATS]"
        },
        {
            "command-line-flag": "-show_timing_ele",
            "description": "display info on the main timing element  With this option, the program will display information regarding the single (possibly modified) timing element.",
            "id": "SHOW_TIMING_ELE",
            "name": "SHOW_TIMING_ELE",
            "optional": true,
            "type": "String",
            "value-key": "[SHOW_TIMING_ELE]"
        },
        {
            "command-line-flag": "-stim_dur",
            "description": "specify the stimulus duration, in seconds  e.g. -stim_dur 3.5  This option allows the user to specify the duration of the stimulus, as applies to the single timing element.  The only use of this is in conjunction with -show_isi_stats.  Consider '-show_isi_stats' and '-run_len'.  --------------------",
            "id": "STIM_DUR",
            "name": "STIM_DUR",
            "optional": true,
            "type": "String",
            "value-key": "[STIM_DUR]"
        },
        {
            "command-line-flag": "-fsl_timing_files",
            "description": "-fsl_timing_files F1 F2 ...   : read a list of FSL formatted timing files  e.g. -fsl_timing_files fsl.s1.run1.txt fsl.s1.run2.txt fsl.s1.run3.txt e.g. -fsl_timing_files fsl.stim.class.A.run.*.txt  This is essentially an alternative to -timing, as the result is a single multi-run timing element.  Each input file should have FSL formatted timing for a single run, and all for the same stimulus class.  Each file should contain a list of entries like:  event_time  duration  amplitude  e.g. with varying durations and amplitudes (fully married)  0         5         3 17.4      4.6       2.5 ...  e.g. with constant durations and (ignored) amplitudes (so not married)  0         2         1 17.4      2         1 ...  e.g. empty (no events)  0         0         0  If all durations are the same, the result will not have duration modulators.  If all amplitudes are 0 or all are 1, the result will not have amplitude modulators.  An empty file or one with a single line of '0 0 0' is considered to have no events (note that 0 0 0 means duration and amplitude of zero).  Comment lines are okay (starting with #).  Consider -write_as_married.  --------------------",
            "id": "FSL_TIMING_FILES",
            "name": "FSL_TIMING_FILES",
            "optional": true,
            "type": "String",
            "value-key": "[FSL_TIMING_FILES]"
        },
        {
            "command-line-flag": "-multi_show_duration_stats",
            "description": "display min/mean/max/stdev of event durations  Show the minimum, mean, maximum and standard deviation of the list of all event durations, for each timing element.",
            "id": "MULTI_SHOW_DURATION_STATS",
            "name": "MULTI_SHOW_DURATION_STATS",
            "optional": true,
            "type": "String",
            "value-key": "[MULTI_SHOW_DURATION_STATS]"
        },
        {
            "command-line-flag": "-multi_show_isi_stats",
            "description": "display timing and ISI statistics  With this option, the program will display timing statistics for the multiple timing files.  If -tr is included, TR offset statistics are also shown.  If -write_all_rest_times is included, write a file of rest durations.",
            "id": "MULTI_SHOW_ISI_STATS",
            "name": "MULTI_SHOW_ISI_STATS",
            "optional": true,
            "type": "String",
            "value-key": "[MULTI_SHOW_ISI_STATS]"
        },
        {
            "command-line-flag": "-multi_show_timing_ele",
            "description": "display info on the multiple timing elements  With this option, the program will display information regarding the multiple timing element list.",
            "id": "MULTI_SHOW_TIMING_ELE",
            "name": "MULTI_SHOW_TIMING_ELE",
            "optional": true,
            "type": "String",
            "value-key": "[MULTI_SHOW_TIMING_ELE]"
        },
        {
            "command-line-flag": "-write_multi_timing",
            "description": "write timing instances to new files  e.g. -write_multi_timing MT.  After modifying the timing data, the multiple timing instances can be written out.  Consider '-write_as_married'.  ------------------------------------------ action options (apply to multi timing elements, only): ------------------------------------------ action options (apply to single timing element, only):  ** Note that these options are processed in the order they are read.",
            "id": "WRITE_MULTI_TIMING",
            "name": "WRITE_MULTI_TIMING",
            "optional": true,
            "type": "String",
            "value-key": "[WRITE_MULTI_TIMING]"
        },
        {
            "command-line-flag": "-add_offset",
            "description": "add OFFSET to every time in main element  e.g. -add_offset -12.0  Use this option to add a single offset to all of the times in the main timing element.  For example, if the user deletes 3 4-second TRs from the EPI data, they may wish to subtract 12 seconds from every stimulus time, so that the times match the modified EPI data.  Consider '-write_timing'.",
            "id": "ADD_OFFSET",
            "name": "ADD_OFFSET",
            "optional": true,
            "type": "String",
            "value-key": "[ADD_OFFSET]"
        },
        {
            "command-line-flag": "-apply_end_times_as_durations",
            "description": "compute durations based on offsets  e.g. -apply_end_times_as_durations next_events.txt  Treat each NEW_FILE event time as the ending of the corresponding INPUT (via -timing) event time to create a duration list.  So they should have the same number of events, and each NEW_FILE time should be just after the corresponding INPUT time.  Consider '-write_timing' and '-show_duration_stats'. Consider example 16.",
            "id": "APPLY_END_TIMES_AS_DURATIONS",
            "name": "APPLY_END_TIMES_AS_DURATIONS",
            "optional": true,
            "type": "String",
            "value-key": "[APPLY_END_TIMES_AS_DURATIONS]"
        },
        {
            "command-line-flag": "-add_rows",
            "description": "append these timing rows to main element  e.g. -add_rows more_times.1D  Use this option to append rows from NEW_FILE to those of the main timing element.  If the user then wrote out the result, it would be identical to using cat: \"cat times1.txt times2.txt > both_times.txt\".  Consider '-write_timing'.",
            "id": "ADD_ROWS",
            "name": "ADD_ROWS",
            "optional": true,
            "type": "String",
            "value-key": "[ADD_ROWS]"
        },
        {
            "command-line-flag": "-extend",
            "description": "extend the timing rows with those in NEW_FILE  e.g. -extend more_times.1D  Use this option to extend each row (run) with the times in NEW_FILE. This has an effect similar to that of '1dcat'.  Sorting the times is optional, done via '-sort'.  Note that 3dDeconvolve does not need the times to be sorted, though it is more understandable to the user.  Consider '-sort' and '-write_timing'.",
            "id": "EXTEND",
            "name": "EXTEND",
            "optional": true,
            "type": "String",
            "value-key": "[EXTEND]"
        },
        {
            "command-line-flag": "-marry_AM",
            "description": "add event modulators based on MTYPE  e.g. -marry_AM lin_run_fraq e.g. -marry_AM lin_event_index  Use this option to add a simple amplitude modulator to events. Current modulator types are:  linear modulators (across events or time):  lin_event_index   : event index, per run (1, 2, 3, ...) lin_run_fraq      : event time, as fractional offset into run (in [0,1])  Non-index modulators require use of -run_len.  Consider example 15.",
            "id": "MARRY_AM",
            "name": "MARRY_AM",
            "optional": true,
            "type": "String",
            "value-key": "[MARRY_AM]"
        },
        {
            "command-line-flag": "-partition",
            "description": "partition the stimulus timing file  e.g. -partition partitions.txt new_times  Use this option to partition the input timing file into multiple timing files based on the labels in a partition file, PART_FILE. The partition file would have the same number of rows and entries on each row as the timing file, but would contain labels to use in partitioning the times into multiple output files.  A label of 0 will cause that timing entry to be dropped.  Otherwise, each distinct label will have those times put into its timing file.  e.g.  timing file: 23.5     46.0     79.3     84.9      116.2 11.4     38.2     69.7     93.5      121.8  partition file: correct  0        0        incorrect incorrect 0        correct  0        correct   correct  ==> results in new_times_good.1D and new_times_bad.1D  new_times_correct.1D: 23.5     0        0        0         0 0        38.2     0        93.5      121.8  new_times_incorrect.1D: 0        0        0        84.9      116.2 *",
            "id": "PARTITION",
            "name": "PARTITION",
            "optional": true,
            "type": "String",
            "value-key": "[PARTITION]"
        },
        {
            "command-line-flag": "-round_times",
            "description": "round times to multiples of the TR 0.0 <= FRAC <= 1.0  e.g. -round_times 0.7  All stimulus times will be rounded to a multiple TR, rounding down if the fraction of the TR that has passed is less than FRAC, rounding up otherwise.  Using the example of FRAC=0.7, if the TR is 2.5 seconds, then times are rounded down if they occur earlier than 1.75 seconds into the TR.  So 11.83 would get rounded up to 12.5, while 11.64 would be rounded down to 10.  FRAC = 1.0 is essentially floor() (as in -truncate_times), while FRAC = 0.0 is essentially ceil().  This option requires -tr.  Consider example 7b.  See also -truncate_times.",
            "id": "ROUND_TIMES",
            "name": "ROUND_TIMES",
            "optional": true,
            "type": "String",
            "value-key": "[ROUND_TIMES]"
        },
        {
            "command-line-flag": "-scale_data",
            "description": "multiply every stim time by SCALAR  e.g. -scale_data 0.975  Use this option to scale (multiply) all times by a single value. This might be useful in effectively changing the TR, or changing the stimulus frequency, if it is regular.  Consider '-write_timing'.",
            "id": "SCALE_DATA",
            "name": "SCALE_DATA",
            "optional": true,
            "type": "String",
            "value-key": "[SCALE_DATA]"
        },
        {
            "command-line-flag": "-show_duration_stats",
            "description": "display min/mean/max/stdev of event durations  Show the minimum, mean, maximum and standard deviation of the list of all event durations.",
            "id": "SHOW_DURATION_STATS",
            "name": "SHOW_DURATION_STATS",
            "optional": true,
            "type": "String",
            "value-key": "[SHOW_DURATION_STATS]"
        },
        {
            "command-line-flag": "-show_timing",
            "description": "display the current single timing data  This prints the current (possibly modified) single timing data to the terminal.  If the user is making multiple modifications to the timing data, they may wish to display the updated timing after each step.",
            "id": "SHOW_TIMING",
            "name": "SHOW_TIMING",
            "optional": true,
            "type": "String",
            "value-key": "[SHOW_TIMING]"
        },
        {
            "command-line-flag": "-show_tr_stats",
            "description": "display within-TR statistics of stimuli  This displays the mean, max and stdev of stimulus times modulo the TR, both in seconds and as fractions of the TR.  See '-warn_tr_stats' for more details.",
            "id": "SHOW_TR_STATS",
            "name": "SHOW_TR_STATS",
            "optional": true,
            "type": "String",
            "value-key": "[SHOW_TR_STATS]"
        },
        {
            "command-line-flag": "-warn_tr_stats",
            "description": "display within-TR stats only for warnings  This is akin to -show_tr_stats, but output is only displayed if there might be a warning based on the timing.  Warnings occur when the minimum fraction is positive and the maximum fraction is small (less than -min_frac, 0.3).  If such warnings are encountered, particularly in the case of TENT basis functions used in the linear regression, they can affect the X-matrix, essentially scaling beta #0 by the reciprocal of the fraction (noise dependent).  In such a case the stimuli are almost TR-locked, and the user might be better off making them exactly TR-locked (by creating new timing files using \"timing_tool.py -round_times\").  See also '-show_tr_stats', '-min_frac' and '-round_times'.",
            "id": "WARN_TR_STATS",
            "name": "WARN_TR_STATS",
            "optional": true,
            "type": "String",
            "value-key": "[WARN_TR_STATS]"
        },
        {
            "command-line-flag": "-sort",
            "description": "sort the times, per row (run)  This will cause each row (run) of the main timing element to be sorted (from smallest to largest).  Such a step may be highly desired after using '-extend', or after some external manipulation that causes the times to be unsorted.  Note that 3dDeconvolve does not require sorted timing.  Consider '-write_timing'.",
            "id": "SORT",
            "name": "SORT",
            "optional": true,
            "type": "String",
            "value-key": "[SORT]"
        },
        {
            "command-line-flag": "-test_local_timing",
            "description": "test for certain problems with local timing  The main purpose of this is to test for timing files that are intended to be interpreted by 3dDeconvolve as being LOCAL TIMES, but might actually be interpreted as being GLOBAL TIMES.  Note that as of 18 Feb, 2014, any '*' in a timing file will cause it to be interpreted by 3dDeconvolve as LOCAL TIMES, even if the file is only a single column.",
            "id": "TEST_LOCAL_TIMING",
            "name": "TEST_LOCAL_TIMING",
            "optional": true,
            "type": "String",
            "value-key": "[TEST_LOCAL_TIMING]"
        },
        {
            "command-line-flag": "-timing_to_1D",
            "description": "-timing_to_1D output.1D      : convert stim_times format to stim_file  e.g. -timing_to_1D stim_file.1D  This action is used to convert stimulus times to set (i.e. 1) values in a 1D stim_file.  Besides an input -timing file, -tr is needed to specify the timing grid of the output 1D file, -stim_dur is needed to specify the duration of each stimulus (which might cross many output TRs), and -run_len is needed to specify the duration of each (or all) of the runs.  The -min_frac option may be applied to give a minimum cutoff for the fraction of a TR occupied by a stimulus required to label that TR as a 1.  If not, the default cutoff is 0.3.  For example, assume options: '-tr 2', '-stim_dur 4.2', '-min_frac 0.2'. A stimulus at time 9.7 would last until 13.9.  TRs 0..4 would certainly be 0, TR 5 would also be 0 as the stimulus covers only .15 of the TR (.3 seconds out of 2 seconds).  TR 6 would be 1 since it is completely covered, and TR 7 would be 1 since .95 (1.9/2) would be covered.  So the resulting 1D file would start with:  0 0 0 0 0 1 1  The main use of this operation is for PPI analysis, to partition the time series (maybe on a fine grid) with 1D files that are 1 when the given stimulus is on and 0 otherwise.  Consider -tr, -stim_dur, -min_frac, -run_len, -per_run_file.  Consider example 6a or 6c.",
            "id": "TIMING_TO_1D",
            "name": "TIMING_TO_1D",
            "optional": true,
            "type": "String",
            "value-key": "[TIMING_TO_1D]"
        },
        {
            "command-line-flag": "-transpose",
            "description": "transpose the data (only if rectangular)  This works exactly like 1dtranspose, and requires each row to have the same number of entries (rectangular data).  The first row would be swapped with the first column, etc.  Consider '-write_timing'.",
            "id": "TRANSPOSE",
            "name": "TRANSPOSE",
            "optional": true,
            "type": "String",
            "value-key": "[TRANSPOSE]"
        },
        {
            "command-line-flag": "-truncate_times",
            "description": "truncate times to multiples of the TR  All stimulus times will be truncated to the largest multiple of the TR that is less than or equal to each respective time.  That is to say, shift each stimulus time to the beginning of its TR.  This is particularly important when stimulus times are at a constant offset into each TR and at the same time using TENT basis functions for regression (in 3dDeconvolve, say).  The shorter the (non-zero) offset, the more correlated the first two tent regressors will be, possibly leading to unpredictable results.  This option requires -tr.  Consider example 7.",
            "id": "TRUNCATE_TIMES",
            "name": "TRUNCATE_TIMES",
            "optional": true,
            "type": "String",
            "value-key": "[TRUNCATE_TIMES]"
        },
        {
            "command-line-flag": "-write_as_married",
            "description": "if possible, force output in married format  e.g. -write_as_married  If all durations are equal, the default is to not write with duration modulation (as the constant duration would likely be provided as part of a basis function).  Use -write_as_married to include any constant duration as a modulator.",
            "id": "WRITE_AS_MARRIED",
            "name": "WRITE_AS_MARRIED",
            "optional": true,
            "type": "String",
            "value-key": "[WRITE_AS_MARRIED]"
        },
        {
            "command-line-flag": "-write_timing",
            "description": "write the current timing to a new file  e.g. -write_timing new_times.1D  After modifying the timing data, the user will probably want to write out the result.  Alternatively, the user could use -show_timing and cut-and-paste to write such a file.  Consider '-write_as_married'.  ------------------------------------------ action options (apply to multi timing elements, only):",
            "id": "WRITE_TIMING",
            "name": "WRITE_TIMING",
            "optional": true,
            "type": "String",
            "value-key": "[WRITE_TIMING]"
        },
        {
            "command-line-flag": "-multi_timing_to_events",
            "description": "create event list from stimulus timing  e.g. -multi_timing_to_events all.events.txt  Decide which TR each stimulus event belongs to and make an event file (of TRs) containing a sequence of values between 0 (no event) and N (the index of the event class, for the N timing files).  This option requires -tr, -multi_stim_dur, -min_frac and -run_len.  Consider example 8.",
            "id": "MULTI_TIMING_TO_EVENTS",
            "name": "MULTI_TIMING_TO_EVENTS",
            "optional": true,
            "type": "String",
            "value-key": "[MULTI_TIMING_TO_EVENTS]"
        },
        {
            "command-line-flag": "-multi_timing_to_event_pair",
            "description": "break event file into 2 pieces  e.g. -multi_timing_to_event_pair events.txt isi.txt  Similar to -multi_timing_to_events, but break the output event file into 2 pieces, an event list and an ISI list.  Each event E followed by K zeros in the previous events file would be broken into a single E (in the new event file) and K+1 (in the ISI file).  Note that K+1 is appropriate from the assumption that events are 0-duration.  The ISI entries should sum to the total number of TRs per run.  Suppose the event file shows 2 TRs of rest, event type 3 followed by 4 TRs of rest, event type 1 followed by 1 TR of rest, type 2 and no rest, type 2 and 3 TRs of rest.  So it would read:  all events:  0 0 3 0 0 0 0 1 0 2 2 0 0 0 ...  Then the event_pair files would read:  events:      0 3 1 2 2 ... ISIs:        2 5 2 1 4 ...  Note that the only 0 events occur at the beginnings of runs. Note that the ISI is always at least 1, for the TR of the event.  This option requires -tr, -multi_stim_dur, -min_frac and -run_len.  Consider example 8b.",
            "id": "MULTI_TIMING_TO_EVENT_PAIR",
            "name": "MULTI_TIMING_TO_EVENT_PAIR",
            "optional": true,
            "type": "String",
            "value-key": "[MULTI_TIMING_TO_EVENT_PAIR]"
        },
        {
            "command-line-flag": "-chrono",
            "description": "process options chronologically  This option has been removed.",
            "id": "CHRONO",
            "name": "CHRONO",
            "optional": true,
            "type": "String",
            "value-key": "[CHRONO]"
        },
        {
            "command-line-flag": "-min_frac",
            "description": "specify minimum TR fraction  e.g. -min_frac 0.1  This option applies to either -timing_to_1D action or -warn_tr_stats.  For -warn_tr_stats (or -show), if the maximum tr fraction is below this limit, TRs are considered to be approximately TR-locked.  For -timing_to_1D, when a random timing stimulus is converted to part of a 0/1 1D file, if the stimulus occupies at least FRAC of a TR, then that TR gets a 1 (meaning it is \"on\"), else it gets a 0 (\"off\").  FRAC is required to be within [0,1], though clearly 0 is not very useful.  Also, 1 is not recommended unless that TR can be stored precisely as a floating point number.  For example, 0.1 cannot be stored exactly, so 0.999 might be safer to basically mean 1.0.  Consider -timing_to_1D.",
            "id": "MIN_FRAC",
            "name": "MIN_FRAC",
            "optional": true,
            "type": "String",
            "value-key": "[MIN_FRAC]"
        },
        {
            "command-line-flag": "-part_init",
            "description": "specify a default partition NAME  e.g.     -part_init 2 e.g.     -part_init frogs default: -part_init INIT  This option applies to '-multi_timing_to_event_list part'.  In the case of generating a partition based on the previous events, this option allow the user to specify the partition class to be used when the class in question comes first (i.e. there is no previous event).  The default class is the label INIT (the other classes will be small integers, from 1 to #inputs).",
            "id": "PART_INIT",
            "name": "PART_INIT",
            "optional": true,
            "type": "String",
            "value-key": "[PART_INIT]"
        },
        {
            "command-line-flag": "-nplaces",
            "description": "specify # decimal places used in printing  e.g. -nplaces 1  This option allows the user to specify the number of places to the right of the decimal that are used when printing a stimulus time (to the screen via -show_timing or to a file via -write_timing). The default is -1, which uses the minimum needed for accuracy.  Consider '-show_timing' and '-write_timing'.",
            "id": "NPLACES",
            "name": "NPLACES",
            "optional": true,
            "type": "String",
            "value-key": "[NPLACES]"
        },
        {
            "command-line-flag": "-mplaces",
            "description": "specify # places used for married fields  e.g. -mplaces 1  Akin to -nplaces, this option controls the number of places to the right of the decimal that are used when printing stimulus event modulators (amplitude and duration modulators). The default is -1, which uses the minimum needed for accuracy.  Consider '-nplaces', '-show_timing' and '-write_timing'.",
            "id": "MPLACES",
            "name": "MPLACES",
            "optional": true,
            "type": "String",
            "value-key": "[MPLACES]"
        },
        {
            "command-line-flag": "-per_run",
            "description": "perform relevant operations per run  e.g. -per_run  This option applies to -timing_to_1D, so that each 0/1 array is one row per run, as opposed to a single column across runs.",
            "id": "PER_RUN",
            "name": "PER_RUN",
            "optional": true,
            "type": "String",
            "value-key": "[PER_RUN]"
        },
        {
            "command-line-flag": "-per_run_file",
            "description": "per run, but output multiple files  e.g. -per_run_file  This option applies to -timing_to_1D, so that the 0/1 array goes in a separate file per run.  With -per_run, each run is just a separate row.",
            "id": "PER_RUN_FILE",
            "name": "PER_RUN_FILE",
            "optional": true,
            "type": "String",
            "value-key": "[PER_RUN_FILE]"
        },
        {
            "command-line-flag": "-tr",
            "description": "specify the time resolution in 1D output (in seconds) e.g. -tr 2.0 e.g. -tr 0.1  For any action that write out 1D formatted data (currently just the",
            "id": "TR",
            "name": "TR",
            "optional": true,
            "type": "String",
            "value-key": "[TR]"
        },
        {
            "command-line-flag": "-verb",
            "description": "set the verbosity level  e.g. -verb 3  This option allows the user to specify how verbose the program is. The default level is 1, 0 is quiet, and the maximum is (currently) 4.",
            "id": "VERB",
            "name": "VERB",
            "optional": true,
            "type": "String",
            "value-key": "[VERB]"
        },
        {
            "command-line-flag": "-write_all_rest_times",
            "description": "write all rest durations to 'timing' file  e.g. -write_all_rest_times all_rest.txt  In the case of a show_isi_stats option, the user can opt to save all rest (pre-stim, isi, post-stim) durations to a timing-style file.  Each row (run) would have one more entry than the number of stimuli (for pre- and post- rest).  Note that pre- and post- might be 0.  ----------------------------------------------------------------------------- R Reynolds    December 2008 =============================================================================",
            "id": "WRITE_ALL_REST_TIMES",
            "name": "WRITE_ALL_REST_TIMES",
            "optional": true,
            "type": "String",
            "value-key": "[WRITE_ALL_REST_TIMES]"
        }
    ],
    "name": "tool name",
    "schema-version": "0.5",
    "suggested-resources": {
        "cpu-cores": 1,
        "ram": 1,
        "walltime-estimate": 60
    },
    "tags": {},
    "tool-version": "v0.1.0"
}